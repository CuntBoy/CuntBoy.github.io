<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bug奇遇记-uint16_t</title>
    <url>/2021/03/19/Bug%E5%A5%87%E9%81%87%E8%AE%B0-uint16-t/</url>
    <content><![CDATA[<h3 id="uint16-t"><a href="#uint16-t" class="headerlink" title="uint16_t"></a>uint16_t</h3><ul>
<li>标准定义中：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint16_t</span>; <span class="comment">// max == _UI16_MAX 0xffffu </span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/CuntBoy/images/main/uint16_t.png" alt="uint16_t" title="uint16"></p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li><font color="red">这是一个粗心的问题</font></li>
</ul>
<p>在我正在实现的功能中有一个数据遍历的部分，我使用了<code>uint16_t</code>类型作为索引的类型，但是<code>uint16_t</code>数据的最大值比较小，所以当基础数据量过大的时候，我们产生的索引会越过索引的最大范围，导致最终得到的索引不是实际需要的索引值，导致我最终绘制的图形不是正确的结果！</p>
<hr>
<h3 id="正确的结果展示："><a href="#正确的结果展示：" class="headerlink" title="正确的结果展示："></a>正确的结果展示：</h3><p><img src="https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_2.png" alt="lum_2" title="result"></p>
<p><img src="https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_1.png" alt="right result" title="Result"></p>
]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
        <category>data type</category>
        <category>bugs</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>OSG-HUD</title>
    <url>/2021/07/26/OSG-HUD/</url>
    <content><![CDATA[<h1 id="OSG-HUD"><a href="#OSG-HUD" class="headerlink" title="OSG-HUD"></a>OSG-HUD</h1><ul>
<li><p>"HUD"在渲染的场景中算是比较常见的存在: 游戏中的小地图(上帝视角)、实时状态、显示鼠标的实时位置、三维视角...</p></li>
</ul>
<p><b style="color:red">如何创建HUD ？</b> </p>
<p>本质上说，HUD就是一个相机( 在`OSG`中可以作为节点)，只是不响应鼠标的操作。只需要设置好相关的参数，添加到场景的根节点就行</p>

<p><b style="color:red">实现要点，如下：</b></p>
<ul>
<li>关闭节点的光照，保证整个视口显示的场景的亮度是一样的。</li>
<li>关闭深度测试</li>
<li>调整渲染的顺序为最后渲染，让<code>HUD</code>显示在整个场景的最前方</li>
<li>设置参考帧为绝对参考帧</li>
<li>设置变换矩阵,不受父节点的影响</li>
<li>设置投影矩阵(平行投影或者透视),设置视口的大小。</li>
</ul>
<h2 id="Create-HUD"><a href="#Create-HUD" class="headerlink" title="Create HUD"></a>Create HUD</h2><h3 id="1、创建相机节点"><a href="#1、创建相机节点" class="headerlink" title="1、创建相机节点"></a>1、创建相机节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">osg::ref_ptr&lt;osg::Camera&gt; hud_camera = <span class="keyword">new</span> osg::Camera;   <span class="comment">// 创建相机的节点</span></span><br><span class="line">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class="keyword">new</span> osg::Geometry;      <span class="comment">// 创建绘制的节点(也可以是文字)</span></span><br></pre></td></tr></table></figure>

<h3 id="2、设置投影矩阵"><a href="#2、设置投影矩阵" class="headerlink" title="2、设置投影矩阵"></a>2、设置投影矩阵</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;setProjectionMatrixAsOrtho2D(<span class="number">-3</span>, <span class="number">4</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1.0</span>, <span class="number">100</span>);  <span class="comment">// 2D 也可以 此处设置表示你裁剪的三维空间的实际的能表示的数值的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="3、设置视口大小-ViewPort"><a href="#3、设置视口大小-ViewPort" class="headerlink" title="3、设置视口大小(ViewPort)"></a>3、设置视口大小(ViewPort)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// void setViewport(osg::Viewport* viewport);</span></span><br><span class="line"><span class="comment">// void setViewport(int x,int y,int width,int height);</span></span><br><span class="line">hud_camera-&gt;setviewport();  <span class="comment">// 两种方式都是可以的 </span></span><br></pre></td></tr></table></figure>

<h3 id="4、设置渲染的顺序"><a href="#4、设置渲染的顺序" class="headerlink" title="4、设置渲染的顺序"></a>4、设置渲染的顺序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;setRenderOrder(osg::Camera::POST_RENDER);</span><br></pre></td></tr></table></figure>

<h3 id="5、设置参考帧"><a href="#5、设置参考帧" class="headerlink" title="5、设置参考帧"></a>5、设置参考帧</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);</span><br></pre></td></tr></table></figure>

<h3 id="6、设置不受父节点的影响"><a href="#6、设置不受父节点的影响" class="headerlink" title="6、设置不受父节点的影响"></a>6、设置不受父节点的影响</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;setViewMatrix(osg::Matrix::identity());</span><br></pre></td></tr></table></figure>

<h3 id="7、设置不获取焦点"><a href="#7、设置不获取焦点" class="headerlink" title="7、设置不获取焦点"></a>7、设置不获取焦点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;setAllowEventFocus(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8、设置节点的更新回调"><a href="#8、设置节点的更新回调" class="headerlink" title="8、设置节点的更新回调"></a>8、设置节点的更新回调</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// void setUpdateCallback(Callback* nc);</span></span><br><span class="line"><span class="comment">// 需要重写一个节点的更新回调 修改节点的视图矩阵 </span></span><br><span class="line"><span class="comment">// 设置相机的三个参数  </span></span><br><span class="line"><span class="comment">// 视点 相机的位置 相机的向上方向</span></span><br><span class="line">hud_camera-&gt;setUpdateCallback();</span><br></pre></td></tr></table></figure>

<h2 id="挂载节点"><a href="#挂载节点" class="headerlink" title="挂载节点"></a>挂载节点</h2><h3 id="1、将前面创建的几何节点挂载到-相机上"><a href="#1、将前面创建的几何节点挂载到-相机上" class="headerlink" title="1、将前面创建的几何节点挂载到 相机上"></a>1、将前面创建的几何节点挂载到 相机上</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">osg::ref_ptr&lt;osg::Geode&gt; node = <span class="keyword">new</span> osg::Geode;</span><br><span class="line">node-&gt;addChild(geom.get());</span><br><span class="line">hud_camera-&gt;addChild(node.get());</span><br></pre></td></tr></table></figure>

<h3 id="2、设置节点的属性"><a href="#2、设置节点的属性" class="headerlink" title="2、设置节点的属性"></a>2、设置节点的属性</h3><ul>
<li>关闭光照 深度测试 &amp; 打开混溶</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> states = node-&gt;getOrCreateStateSet();</span><br><span class="line">states-&gt;setMode(GL_LIGHTING, osg::StateAttribute::ON);   <span class="comment">//关闭灯光</span></span><br><span class="line">states-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);<span class="comment">//关闭深度测试</span></span><br><span class="line">states-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);  </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>OSG踩坑记-模型共享&amp;模型颜色修改</title>
    <url>/2021/03/20/OSG%E8%B8%A9%E5%9D%91%E8%AE%B0-%E6%A8%A1%E5%9E%8B%E5%85%B1%E4%BA%AB-%E6%A8%A1%E5%9E%8B%E9%A2%9C%E8%89%B2%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h3 id="简单概述"><a href="#简单概述" class="headerlink" title="简单概述"></a>简单概述</h3><p>在很多场景中，我们需要将同一个模型绘制到不同的区域并且还需要对模型进行一系列的旋转缩放等操作，同时需要使用不同的颜色，这个时候我们只需要使用一些简单的设置便可以实现这个功能功能。</p>
<h3 id="伪代码："><a href="#伪代码：" class="headerlink" title="伪代码："></a>伪代码：</h3><h4 id="1、读入模型"><a href="#1、读入模型" class="headerlink" title="1、读入模型"></a>1、读入模型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无论你是从外部读入模型 还是你自己构建的一个模型都是可以的。</span></span><br><span class="line"><span class="comment">// 使用osg自带读取模型的函数读取模型</span></span><br><span class="line"><span class="comment">// 推荐使用 osg 的智能指针</span></span><br><span class="line"><span class="comment">// 此处使用一个 内嵌的几何体 代替模型 </span></span><br><span class="line"></span><br><span class="line">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class="keyword">new</span> osg::Geometry; </span><br><span class="line"><span class="comment">// osg 的智能指针采用引用计数的方式决定当前对象是否释放</span></span><br></pre></td></tr></table></figure>

<h4 id="2、计算对模型的旋转、缩放、平移的操作矩阵"><a href="#2、计算对模型的旋转、缩放、平移的操作矩阵" class="headerlink" title="2、计算对模型的旋转、缩放、平移的操作矩阵"></a>2、计算对模型的旋转、缩放、平移的操作矩阵</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// osg 有专门用户模型操作的类  osg::MatrixTransform </span></span><br><span class="line"><span class="comment">// 创建一个对象 模型操作类中抽象了矩阵的接口 可以当做矩阵操作 本质上是一个节点 </span></span><br><span class="line">osg::ref_ptr&lt;osg::MatrixTransform&gt; trans = <span class="keyword">new</span> osg::MatrixTransform;</span><br><span class="line"><span class="comment">// 对于模型的操作，有PVM矩阵的意思 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建旋转矩阵 </span></span><br><span class="line">osg::Matrix matrix_rotate;</span><br><span class="line"><span class="comment">// 构建旋转，从osg坐标系的沿着Z轴方向转到X轴（都是正方向）  </span></span><br><span class="line">matrix_rotate.makeRotate(osg::vec3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>),osg::vec3(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>));  <span class="comment">// 参数分别是两个方向向量 第一个参数是当前模型的方向 第二个参数是你需要旋转的方向</span></span><br><span class="line"><span class="comment">// 你也可以直接选择使用</span></span><br><span class="line">osg::Matrix::rotate(osg::Vec3(),osg::Vec3()); <span class="comment">// 输入的参数也可以是四元数  返回值是一个表示旋转的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================================================================================</span></span><br><span class="line"><span class="comment">// 也可以直接 设置最终的变换矩阵 </span></span><br><span class="line">trans-&gt;setMatrix(matrix_rotate * osg::Martix::scale(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>) * osg::translate(osg::Vec3()));</span><br><span class="line"><span class="comment">// trans 已经存储了 我们对于模型的操作 </span></span><br></pre></td></tr></table></figure>

<h4 id="3、对trans节点设置材料等属性"><a href="#3、对trans节点设置材料等属性" class="headerlink" title="3、对trans节点设置材料等属性"></a>3、对trans节点设置材料等属性</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建材质对象</span></span><br><span class="line">osg::Material* mat = <span class="keyword">new</span> osg::Material();</span><br><span class="line">mat-&gt;setColorMode(osg::Material::ColorMode::DIFFUSE);   <span class="comment">// 设置绘制颜色的模式 </span></span><br><span class="line">mat-&gt;setDiffuse(osg::Material::FRONT, osg::Vec4());      <span class="comment">// 设置此种模式下的颜色 </span></span><br><span class="line"></span><br><span class="line">trans-&gt;getOrCreateStateSet()-&gt;setAttribute(mat);        <span class="comment">// 将材质设置给 节点 </span></span><br></pre></td></tr></table></figure>

<h4 id="4、将对象作为节点添加"><a href="#4、将对象作为节点添加" class="headerlink" title="4、将对象作为节点添加"></a>4、将对象作为节点添加</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">trans.addchild(geom.get());</span><br></pre></td></tr></table></figure>

<h4 id="5、将操作节点添加到绘制的根节点或者是其他的叶节点"><a href="#5、将操作节点添加到绘制的根节点或者是其他的叶节点" class="headerlink" title="5、将操作节点添加到绘制的根节点或者是其他的叶节点"></a>5、将操作节点添加到绘制的根节点或者是其他的叶节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
        <category>OSG</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>Boy</title>
    <url>/2021/03/16/baozi/</url>
    <content><![CDATA[<h4 id="About-this-Blog"><a href="#About-this-Blog" class="headerlink" title="About this Blog"></a>About this Blog</h4><ul>
<li>个人博客，分享我的日常与一些工作内容</li>
</ul>
]]></content>
      <categories>
        <category>bun</category>
        <category>life</category>
      </categories>
      <tags>
        <tag>intraduce</tag>
      </tags>
  </entry>
  <entry>
    <title>迟到的毕业总结</title>
    <url>/2021/03/18/%E8%BF%9F%E5%88%B0%E7%9A%84%E6%AF%95%E4%B8%9A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p> <font color="red">2020年</font>在三个月前结束了，这一年大家都收获了满满的经历。当然，我也是。我毕业了，从一个三流学校的渣子变成了社会末流的青年。开始了独属于我的关于这个时代的苟且！</p>
<p>​    离开前，大家都像是急于归乡的游子，对身后的这个城市不存半点留恋。</p>
<p>对于大学，我仿佛有千言万语，却是欲语还休 。不谈这个这个有些无聊的学校，关于大学，关于这四年，关于我自己，我希望它是美好的，会让我主动怀恋的！</p>
<p>待续。。。</p>
<hr>
<p><code>2021-7-26</code></p>
<p>​    下个月就要离开这个城市了，目前心情很是平淡，谈不上悲，亦没有欢喜，我仿佛早有预料一般。却如其实，我的确早有离开的想法，我大学的四年在这个城市度过，对于这里的大部分事物，我也算是熟悉，离开这里对我来说麻烦的地方便是新的城市，新的交际。。。<br>当然一切都会是新的，我也是。</p>
<p>​    祝愿我将迎接新的美好，朋友我来了！</p>
]]></content>
      <categories>
        <category>bun</category>
        <category>university</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>conclusion</tag>
      </tags>
  </entry>
  <entry>
    <title>OSG踩坑记-默认光源</title>
    <url>/2021/04/04/OSG%E8%B8%A9%E5%9D%91%E8%AE%B0-%E9%BB%98%E8%AE%A4%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<h3 id="OSG-Viewer默认光源"><a href="#OSG-Viewer默认光源" class="headerlink" title="OSG-Viewer默认光源"></a>OSG-Viewer默认光源</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">osg::Node-&gt;getOrCreateStateSet()-&gt;setMode(GL_RESCALE_NORMAL, osg::StateAttribute::ON);    <span class="comment">// 法线随着模型大小变化而变化。</span></span><br><span class="line">osg::Node-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE); <span class="comment">// 关闭节点光源 并遵从父节点的光照设置</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="不指定法向-–-仍然可以看到-光照效果-但是无法看到明暗变化"><a href="#不指定法向-–-仍然可以看到-光照效果-但是无法看到明暗变化" class="headerlink" title="不指定法向 – 仍然可以看到 光照效果 但是无法看到明暗变化 "></a><code>不指定法向</code> – <font color="red">仍然可以看到 光照效果 但是无法看到明暗变化 </font></h5><h3 id="Viewer-默认光源的使用"><a href="#Viewer-默认光源的使用" class="headerlink" title="Viewer 默认光源的使用"></a>Viewer 默认光源的使用</h3><h4 id="1、设置光照的相关的信息"><a href="#1、设置光照的相关的信息" class="headerlink" title="1、设置光照的相关的信息"></a>1、设置光照的相关的信息</h4><ul>
<li><p><code>osg::Viewer默认存在缺省光源,但是需要进行部分设置,不然可能与你当前的场景不匹配</code></p>
</li>
<li><p>你需要设置的信息包括: ambient、diffuse、specular、光照方向（可以不设置，使用缺省的）、光照位置、光的衰减参数。</p>
</li>
</ul>
<blockquote>
<p>设置光照  – <font color="Green">衰减公式</font><br>$$<br>F = \frac{1}{(k_c + k_l<em>d + k_q</em>d^2)}<br>$$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取缺省的光照</span></span><br><span class="line">osg::Light *light = viewer-&gt;getLight(); <span class="comment">// 从当前的查看器 获取光照设置 </span></span><br><span class="line">light-&gt;setAmbient(osg::Vec4(<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">1.0</span>));   <span class="comment">// 环境光   OPENGL的默认值是 osg::Vec3(0.2,0.2,0.2);</span></span><br><span class="line">light-&gt;setDiffuse(osg::Vec4(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1.0</span>));   <span class="comment">// 漫反射   直接来源于光源</span></span><br><span class="line">light-&gt;setSpecular(osg::Vec4(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span>));  <span class="comment">// specular   高光 此处给的很低  </span></span><br><span class="line"><span class="comment">// 由于此处我们使用的是平行光</span></span><br><span class="line"><span class="function">osg::Vec4 <span class="title">lightpos</span><span class="params">(x, y, z, <span class="number">0.0f</span>)</span></span>;   <span class="comment">// 记住: 平行光的位置的最后一个分量必须是 0 </span></span><br><span class="line">light-&gt;setPosition(lightpos);        <span class="comment">// 设置光照位置 </span></span><br><span class="line"><span class="comment">// 光照方向设置</span></span><br><span class="line"><span class="comment">// 需要用到高度角和方位角 -- 计算一个你需要方向 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置光的衰减 -- 只设置 常量衰减的话 --   无距离衰减</span></span><br><span class="line">light-&gt;setConstantAttenuation(<span class="number">1.0f</span>);</span><br><span class="line">light-&gt;setLinearAttenuation(<span class="number">0.0f</span>);</span><br><span class="line">light-&gt;setQuadraticAttenuation(<span class="number">0.f</span>);</span><br></pre></td></tr></table></figure>

<p><font color="red"> 产生平行光，位置分量的第四分量必须是0 </font></p>
<h4 id="2、对节点设置好材料属性"><a href="#2、对节点设置好材料属性" class="headerlink" title="2、对节点设置好材料属性"></a>2、对节点设置好材料属性</h4><ul>
<li>材料的设置是针对你要显示的节点设置的、你可以创建一个材料并设置相关的颜色，这样就可以拥有一个更好的显示效果。</li>
</ul>
]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
        <category>OSG</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
</search>
